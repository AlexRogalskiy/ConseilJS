parameter (or (or (or (or (or (pair %build (pair (string %game) (address %player1)) (address %player2)) (string %game)) (pair %play (pair (pair (string %game) (int %i)) (int %j)) (int %move))) (pair %setGameMetaData (pair (string %game) (string %name)) (string %value))) (pair %setMetaData (string %name) (string %value))) (bool %setPause));

storage (pair (big_map %boards string (pair (pair (pair (pair (pair (pair (pair (map %deck int (map int int)) (bool %draw)) (map %metaData string string)) (int %nbMoves)) (int %nextPlayer)) (address %player1)) (address %player2)) (int %winner))) (pair (pair (address %admin) (map %metaData string string)) (bool %paused)));

code
  {
    DUP;        # pair(params, storage).pair(params, storage)
    CDR;        # storage.pair(params, storage)
    SWAP;       # pair(params, storage).storage
    CAR;        # params.storage
    IF_LEFT
      {
        IF_LEFT
          {
            IF_LEFT
              {
                IF_LEFT
                  {
                    IF_LEFT
                      {
                        # Entry point: build # params.storage
                        PAIR;       # pair(params, storage)
                        # sp.verify((~ self.data.paused) | (sp.sender == self.data.admin)) # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDDDR;      # bool.pair(params, storage)
                        NOT;        # bool.pair(params, storage)
                        IF
                          {
                            PUSH bool True; # bool.pair(params, storage)
                          }
                          {
                            DUP;        # pair(params, storage).pair(params, storage)
                            CDDAAR;     # address.pair(params, storage)
                            SENDER;     # address.address.pair(params, storage)
                            COMPARE;    # int.pair(params, storage)
                            EQ;         # bool.pair(params, storage)
                          }; # bool.pair(params, storage)
                        IF
                          {}
                          {
                            PUSH string "WrongCondition: (~ self.data.paused) | (sp.sender == self.data.admin)"; # string.pair(params, storage)
                            FAILWITH;   # pair(params, storage)
                          }; # pair(params, storage)
                        # sp.verify(~ (params.game in self.data.boards)) # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAR;      # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        MEM;        # bool.pair(params, storage)
                        NOT;        # bool.pair(params, storage)
                        IF
                          {}
                          {
                            PUSH string "WrongCondition: ~ (params.game in self.data.boards)"; # string.pair(params, storage)
                            FAILWITH;   # pair(params, storage)
                          }; # pair(params, storage)
                        # self.data.boards[params.game] = Record(deck = [[0, 0, 0], [0, 0, 0], [0, 0, 0]], draw = False, metaData = {}, nbMoves = 0, nextPlayer = 1, player1 = params.player1, player2 = params.player2, winner = 0) # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAR;      # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUP;     # pair(params, storage).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # Rec(game = string, player1 = address, player2 = address).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CDR;        # address.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # int.address.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAADR;      # address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 1; # int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # intOrNat.int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        EMPTY_MAP string string; # Map(string, string).intOrNat.int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH bool False; # bool.Map(string, string).intOrNat.int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH (map int (map int int)) {Elt 0 {Elt 0 0; Elt 1 0; Elt 2 0; }; Elt 1 {Elt 0 0; Elt 1 0; Elt 2 0; }; Elt 2 {Elt 0 0; Elt 1 0; Elt 2 0; }}; # [[int]].bool.Map(string, string).intOrNat.int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair([[int]], bool).Map(string, string).intOrNat.int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(pair([[int]], bool), Map(string, string)).intOrNat.int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(pair(pair([[int]], bool), Map(string, string)), intOrNat).int.address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(pair(pair(pair([[int]], bool), Map(string, string)), intOrNat), int).address.address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(pair(pair(pair(pair([[int]], bool), Map(string, string)), intOrNat), int), address).address.int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(pair(pair(pair(pair(pair([[int]], bool), Map(string, string)), intOrNat), int), address), address).int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(pair(pair(pair(pair(pair(pair([[int]], bool), Map(string, string)), intOrNat), int), address), address), int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SOME;       # option(pair(pair(pair(pair(pair(pair(pair([[int]], bool), Map(string, string)), intOrNat), int), address), address), int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.option(pair(pair(pair(pair(pair(pair(pair([[int]], bool), Map(string, string)), intOrNat), int), address), address), int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        DROP;       # storage
                        NIL operation; # operations.storage
                        PAIR;       # pair(operations, storage)
                      }
                      {
                        # Entry point: deleteGame # params.storage
                        PAIR;       # pair(params, storage)
                        # sp.verify(sp.sender == self.data.admin) # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDDAAR;     # address.pair(params, storage)
                        SENDER;     # address.address.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                        IF
                          {}
                          {
                            PUSH string "WrongCondition: sp.sender == self.data.admin"; # string.pair(params, storage)
                            FAILWITH;   # pair(params, storage)
                          }; # pair(params, storage)
                        # del self.data.boards[params.game] # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # params.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        NONE (pair (pair (pair (pair (pair (pair (pair (map %deck int (map int int)) (bool %draw)) (map %metaData string string)) (int %nbMoves)) (int %nextPlayer)) (address %player1)) (address %player2)) (int %winner)); # Cons(None unit | Some Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.Cons(None unit | Some Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        DROP;       # storage
                        NIL operation; # operations.storage
                        PAIR;       # pair(operations, storage)
                      }; # pair(operations, storage)
                  }
                  {
                    # Entry point: play # params.storage
                    PAIR;       # pair(params, storage)
                    # sp.verify(~ self.data.paused) # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDDDR;      # bool.pair(params, storage)
                    NOT;        # bool.pair(params, storage)
                    IF
                      {}
                      {
                        PUSH string "WrongCondition: ~ self.data.paused"; # string.pair(params, storage)
                        FAILWITH;   # pair(params, storage)
                      }; # pair(params, storage)
                    # sp.verify((self.data.boards[params.game].winner == 0) & (~ self.data.boards[params.game].draw)) # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 0; # int.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                    CDR;        # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    EQ;         # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAADR;  # bool.pair(params, storage)
                        NOT;        # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {}
                      {
                        PUSH string "WrongCondition: (self.data.boards[params.game].winner == 0) & (~ self.data.boards[params.game].draw)"; # string.pair(params, storage)
                        FAILWITH;   # pair(params, storage)
                      }; # pair(params, storage)
                    # sp.verify((params.i >= 0) & (params.i < 3)) # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CAR;        # Rec(game = string, i = intOrNat, j = intOrNat, move = int).pair(params, storage)
                    CAADR;      # intOrNat.pair(params, storage)
                    PUSH int 0; # intOrNat.intOrNat.pair(params, storage)
                    SWAP;       # intOrNat.intOrNat.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    GE;         # bool.pair(params, storage)
                    IF
                      {
                        PUSH int 3; # intOrNat.pair(params, storage)
                        DUUP;       # pair(params, storage).intOrNat.pair(params, storage)
                        CAAADR;     # intOrNat.intOrNat.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        LT;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {}
                      {
                        PUSH string "WrongCondition: (params.i >= 0) & (params.i < 3)"; # string.pair(params, storage)
                        FAILWITH;   # pair(params, storage)
                      }; # pair(params, storage)
                    # sp.verify((params.j >= 0) & (params.j < 3)) # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CAR;        # Rec(game = string, i = intOrNat, j = intOrNat, move = int).pair(params, storage)
                    CADR;       # intOrNat.pair(params, storage)
                    PUSH int 0; # intOrNat.intOrNat.pair(params, storage)
                    SWAP;       # intOrNat.intOrNat.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    GE;         # bool.pair(params, storage)
                    IF
                      {
                        PUSH int 3; # intOrNat.pair(params, storage)
                        DUUP;       # pair(params, storage).intOrNat.pair(params, storage)
                        CAADR;      # intOrNat.intOrNat.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        LT;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {}
                      {
                        PUSH string "WrongCondition: (params.j >= 0) & (params.j < 3)"; # string.pair(params, storage)
                        FAILWITH;   # pair(params, storage)
                      }; # pair(params, storage)
                    # sp.verify(params.move == self.data.boards[params.game].nextPlayer) # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                    CAAADR;     # int.pair(params, storage)
                    DUUP;       # pair(params, storage).int.pair(params, storage)
                    CADR;       # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    EQ;         # bool.pair(params, storage)
                    IF
                      {}
                      {
                        PUSH string "WrongCondition: params.move == self.data.boards[params.game].nextPlayer"; # string.pair(params, storage)
                        FAILWITH;   # pair(params, storage)
                      }; # pair(params, storage)
                    # sp.verify(self.data.boards[params.game].deck[params.i][params.j] == 0) # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 0; # int.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                    CAAAAAAAR;  # [[int]].int.pair(params, storage)
                    DUUUP;      # pair(params, storage).[[int]].int.pair(params, storage)
                    CAAADR;     # intOrNat.[[int]].int.pair(params, storage)
                    GET;        # option([int]).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # [int].int.pair(params, storage)
                      }; # [int].int.pair(params, storage)
                    DUUUP;      # pair(params, storage).[int].int.pair(params, storage)
                    CAADR;      # intOrNat.[int].int.pair(params, storage)
                    GET;        # option(int).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # int.int.pair(params, storage)
                      }; # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    EQ;         # bool.pair(params, storage)
                    IF
                      {}
                      {
                        PUSH string "WrongCondition: self.data.boards[params.game].deck[params.i][params.j] == 0"; # string.pair(params, storage)
                        FAILWITH;   # pair(params, storage)
                      }; # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CAR;        # Rec(game = string, i = intOrNat, j = intOrNat, move = int).pair(params, storage)
                    CDR;        # int.pair(params, storage)
                    PUSH int 1; # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    EQ;         # bool.pair(params, storage)
                    IF
                      {
                        # sp.verify(sp.sender == self.data.boards[params.game].player1) # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAADR;      # address.pair(params, storage)
                        SENDER;     # address.address.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                        IF
                          {}
                          {
                            PUSH string "WrongCondition: sp.sender == self.data.boards[params.game].player1"; # string.pair(params, storage)
                            FAILWITH;   # pair(params, storage)
                          }; # pair(params, storage)
                      }
                      {
                        # sp.verify(sp.sender == self.data.boards[params.game].player2) # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CADR;       # address.pair(params, storage)
                        SENDER;     # address.address.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                        IF
                          {}
                          {
                            PUSH string "WrongCondition: sp.sender == self.data.boards[params.game].player2"; # string.pair(params, storage)
                            FAILWITH;   # pair(params, storage)
                          }; # pair(params, storage)
                      }; # pair(params, storage)
                    # self.data.boards[params.game].nextPlayer = 3 - self.data.boards[params.game].nextPlayer # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # storage.pair(params, storage)
                    DUP;        # storage.storage.pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                    DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                    DIP
                      {
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUP;     # storage.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUUUP;   # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAADR;     # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PUSH int 3; # int.int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SUB;        # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SET_CAAADR; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SOME;       # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # string.option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                    SWAP;       # pair(params, storage).storage
                    CAR;        # params.storage
                    PAIR;       # pair(params, storage)
                    # self.data.boards[params.game].deck[params.i][params.j] = params.move # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # storage.pair(params, storage)
                    DUP;        # storage.storage.pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                    DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                    DIP
                      {
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUP;        # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAAAAAR;  # [[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUUUP;   # pair(params, storage).[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAADR;     # intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(intOrNat, [[int]]).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUP;        # pair(intOrNat, [[int]]).pair(intOrNat, [[int]]).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DIP
                      {
                        UNPAIR;     # intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # pair(intOrNat, [[int]]).intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UNPAIR;     # intOrNat.[[int]].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    GET;        # option([int]).intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # [int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # [int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUUUUUP; # pair(params, storage).[int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAADR;      # intOrNat.[int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUUUUUUP; # pair(params, storage).intOrNat.[int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CADR;       # int.intOrNat.[int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SOME;       # option(int).intOrNat.[int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # intOrNat.option(int).[int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UPDATE;     # [int].intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SOME;       # option([int]).intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # intOrNat.option([int]).[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UPDATE;     # [[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).[[int]].string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SET_CAAAAAAAR; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SOME;       # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # string.option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                    SWAP;       # pair(params, storage).storage
                    CAR;        # params.storage
                    PAIR;       # pair(params, storage)
                    # self.data.boards[params.game].nbMoves += 1 # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # storage.pair(params, storage)
                    DUP;        # storage.storage.pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                    DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                    DIP
                      {
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUP;     # storage.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PUSH int 1; # intOrNat.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    DUUUUUUUP;  # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    CAAAADR;    # intOrNat.intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    ADD;        # intOrNat.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).intOrNat.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SET_CAAAADR; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SOME;       # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # string.option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                    PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                    SWAP;       # pair(params, storage).storage
                    CAR;        # params.storage
                    PAIR;       # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 0; # int.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                    CAAAAAAAR;  # [[int]].int.pair(params, storage)
                    DUUUP;      # pair(params, storage).[[int]].int.pair(params, storage)
                    CAAADR;     # intOrNat.[[int]].int.pair(params, storage)
                    GET;        # option([int]).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # [int].int.pair(params, storage)
                      }; # [int].int.pair(params, storage)
                    PUSH int 0; # intOrNat.[int].int.pair(params, storage)
                    GET;        # option(int).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # int.int.pair(params, storage)
                      }; # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    NEQ;        # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        DUUP;       # pair(params, storage).[[int]].pair(params, storage)
                        CAAADR;     # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        PUSH int 1; # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        DUUUP;      # pair(params, storage).[[int]].int.pair(params, storage)
                        CAAADR;     # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        DUUP;       # pair(params, storage).[[int]].pair(params, storage)
                        CAAADR;     # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        PUSH int 2; # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        DUUUP;      # pair(params, storage).[[int]].int.pair(params, storage)
                        CAAADR;     # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        # self.data.boards[params.game].winner = self.data.boards[params.game].deck[params.i][0] # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DIP
                          {
                            UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUP;     # storage.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAAAAR;  # [[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAADR;     # intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option([int]).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # intOrNat.[int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # [[int]].int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair([[int]], int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SOME;       # option(pair([[int]], int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.option(pair([[int]], int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        CAR;        # params.storage
                        PAIR;       # pair(params, storage)
                      }
                      {}; # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 0; # int.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                    CAAAAAAAR;  # [[int]].int.pair(params, storage)
                    PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                    GET;        # option([int]).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # [int].int.pair(params, storage)
                      }; # [int].int.pair(params, storage)
                    DUUUP;      # pair(params, storage).[int].int.pair(params, storage)
                    CAADR;      # intOrNat.[int].int.pair(params, storage)
                    GET;        # option(int).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # int.int.pair(params, storage)
                      }; # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    NEQ;        # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        PUSH int 1; # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        DUUP;       # pair(params, storage).[int].pair(params, storage)
                        CAADR;      # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        DUUUP;      # pair(params, storage).[int].int.pair(params, storage)
                        CAADR;      # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        PUSH int 2; # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        DUUP;       # pair(params, storage).[int].pair(params, storage)
                        CAADR;      # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        DUUUP;      # pair(params, storage).[int].int.pair(params, storage)
                        CAADR;      # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        # self.data.boards[params.game].winner = self.data.boards[params.game].deck[0][params.j] # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DIP
                          {
                            UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUP;     # storage.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAAAAR;  # [[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option([int]).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).[int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAADR;      # intOrNat.[int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # [[int]].int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair([[int]], int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SOME;       # option(pair([[int]], int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.option(pair([[int]], int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        CAR;        # params.storage
                        PAIR;       # pair(params, storage)
                      }
                      {}; # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 0; # int.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                    CAAAAAAAR;  # [[int]].int.pair(params, storage)
                    PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                    GET;        # option([int]).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # [int].int.pair(params, storage)
                      }; # [int].int.pair(params, storage)
                    PUSH int 0; # intOrNat.[int].int.pair(params, storage)
                    GET;        # option(int).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # int.int.pair(params, storage)
                      }; # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    NEQ;        # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        PUSH int 1; # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        PUSH int 1; # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        PUSH int 2; # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        PUSH int 2; # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        # self.data.boards[params.game].winner = self.data.boards[params.game].deck[0][0] # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DIP
                          {
                            UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUP;     # storage.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAAAAR;  # [[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option([int]).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # intOrNat.[int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # [[int]].int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair([[int]], int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SOME;       # option(pair([[int]], int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.option(pair([[int]], int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        CAR;        # params.storage
                        PAIR;       # pair(params, storage)
                      }
                      {}; # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 0; # int.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                    CAAAAAAAR;  # [[int]].int.pair(params, storage)
                    PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                    GET;        # option([int]).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # [int].int.pair(params, storage)
                      }; # [int].int.pair(params, storage)
                    PUSH int 2; # intOrNat.[int].int.pair(params, storage)
                    GET;        # option(int).int.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # int.int.pair(params, storage)
                      }; # int.int.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    NEQ;        # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        PUSH int 1; # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        PUSH int 1; # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        PUSH int 2; # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                        CAAAAAAAR;  # [[int]].pair(params, storage)
                        PUSH int 2; # intOrNat.[[int]].pair(params, storage)
                        GET;        # option([int]).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].pair(params, storage)
                          }; # [int].pair(params, storage)
                        PUSH int 0; # intOrNat.[int].pair(params, storage)
                        GET;        # option(int).pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.pair(params, storage)
                          }; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CAAAAAAAR;  # [[int]].int.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].int.pair(params, storage)
                        GET;        # option([int]).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].int.pair(params, storage)
                          }; # [int].int.pair(params, storage)
                        PUSH int 2; # intOrNat.[int].int.pair(params, storage)
                        GET;        # option(int).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.int.pair(params, storage)
                          }; # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        # self.data.boards[params.game].winner = self.data.boards[params.game].deck[0][2] # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DIP
                          {
                            UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUP;     # storage.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUUUUP;   # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAAAAR;  # [[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 0; # intOrNat.[[int]].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option([int]).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # [int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH int 2; # intOrNat.[int].Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # int.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAR;        # [[int]].int.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair([[int]], int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SOME;       # option(pair([[int]], int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.option(pair([[int]], int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        CAR;        # params.storage
                        PAIR;       # pair(params, storage)
                      }
                      {}; # pair(params, storage)
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDR;        # Rec(admin = address, boards = BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), metaData = Map(string, string), paused = bool).pair(params, storage)
                    CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    PUSH int 9; # intOrNat.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.pair(params, storage)
                    DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.pair(params, storage)
                    CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).intOrNat.pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).intOrNat.pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).intOrNat.pair(params, storage)
                    CAAAADR;    # intOrNat.intOrNat.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    EQ;         # bool.pair(params, storage)
                    IF
                      {
                        PUSH int 0; # int.pair(params, storage)
                        DUUP;       # pair(params, storage).int.pair(params, storage)
                        CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).int.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).int.pair(params, storage)
                        CDR;        # int.int.pair(params, storage)
                        COMPARE;    # int.pair(params, storage)
                        EQ;         # bool.pair(params, storage)
                      }
                      {
                        PUSH bool False; # bool.pair(params, storage)
                      }; # bool.pair(params, storage)
                    IF
                      {
                        # self.data.boards[params.game].draw = True # pair(params, storage)
                        DUP;        # pair(params, storage).pair(params, storage)
                        CDR;        # storage.pair(params, storage)
                        DUP;        # storage.storage.pair(params, storage)
                        CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        CAAAAR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                        DIP
                          {
                            UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        IF_SOME
                          {}
                          {
                            FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                          }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PUSH bool True; # bool.Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).bool.string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SET_CAAAAAADR; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SOME;       # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # string.option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                        SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                        PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                        SWAP;       # pair(params, storage).storage
                        CAR;        # params.storage
                        PAIR;       # pair(params, storage)
                      }
                      {}; # pair(params, storage)
                    CDR;        # storage
                    NIL operation; # operations.storage
                    PAIR;       # pair(operations, storage)
                  }; # pair(operations, storage)
              }
              {
                # Entry point: setGameMetaData # params.storage
                PAIR;       # pair(params, storage)
                # sp.verify((sp.sender == self.data.admin) | (sp.sender == self.data.boards[params.game].player1)) # pair(params, storage)
                DUP;        # pair(params, storage).pair(params, storage)
                CDDAAR;     # address.pair(params, storage)
                SENDER;     # address.address.pair(params, storage)
                COMPARE;    # int.pair(params, storage)
                EQ;         # bool.pair(params, storage)
                IF
                  {
                    PUSH bool True; # bool.pair(params, storage)
                  }
                  {
                    DUP;        # pair(params, storage).pair(params, storage)
                    CDAR;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    DUUP;       # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    CAAAR;      # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                    IF_SOME
                      {}
                      {
                        FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                      }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).pair(params, storage)
                    CAADR;      # address.pair(params, storage)
                    SENDER;     # address.address.pair(params, storage)
                    COMPARE;    # int.pair(params, storage)
                    EQ;         # bool.pair(params, storage)
                  }; # bool.pair(params, storage)
                IF
                  {}
                  {
                    PUSH string "WrongCondition: (sp.sender == self.data.admin) | (sp.sender == self.data.boards[params.game].player1)"; # string.pair(params, storage)
                    FAILWITH;   # pair(params, storage)
                  }; # pair(params, storage)
                # self.data.boards[params.game].metaData[params.name] = params.value # pair(params, storage)
                DUP;        # pair(params, storage).pair(params, storage)
                CDR;        # storage.pair(params, storage)
                DUP;        # storage.storage.pair(params, storage)
                CAR;        # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                DUUUP;      # pair(params, storage).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                CAAAR;      # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                PAIR;       # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                DUP;        # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).storage.pair(params, storage)
                DIP
                  {
                    UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                  }; # pair(string, BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int))).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                UNPAIR;     # string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                GET;        # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                IF_SOME
                  {}
                  {
                    FAIL;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                  }; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                DUP;        # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                CAAAAADR;   # Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                DUUUUUUP;   # pair(params, storage).Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                CAADR;      # string.Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                DUUUUUUUP;  # pair(params, storage).string.Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                CADR;       # string.string.Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SOME;       # option(string).string.Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SWAP;       # string.option(string).Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                UPDATE;     # Map(string, string).Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SWAP;       # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).Map(string, string).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SET_CAAAAADR; # Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SOME;       # option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).string.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SWAP;       # string.option(Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                UPDATE;     # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                SWAP;       # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                CDR;        # storage.BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).pair(params, storage)
                SWAP;       # BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)).storage.pair(params, storage)
                PAIR;       # pair(BigMap(string, Rec(deck = [[int]], draw = bool, metaData = Map(string, string), nbMoves = intOrNat, nextPlayer = int, player1 = address, player2 = address, winner = int)), storage).pair(params, storage)
                SWAP;       # pair(params, storage).storage
                DROP;       # storage
                NIL operation; # operations.storage
                PAIR;       # pair(operations, storage)
              }; # pair(operations, storage)
          }
          {
            # Entry point: setMetaData # params.storage
            PAIR;       # pair(params, storage)
            # sp.verify(sp.sender == self.data.admin) # pair(params, storage)
            DUP;        # pair(params, storage).pair(params, storage)
            CDDAAR;     # address.pair(params, storage)
            SENDER;     # address.address.pair(params, storage)
            COMPARE;    # int.pair(params, storage)
            EQ;         # bool.pair(params, storage)
            IF
              {}
              {
                PUSH string "WrongCondition: sp.sender == self.data.admin"; # string.pair(params, storage)
                FAILWITH;   # pair(params, storage)
              }; # pair(params, storage)
            # self.data.metaData[params.name] = params.value # pair(params, storage)
            DUP;        # pair(params, storage).pair(params, storage)
            CDR;        # storage.pair(params, storage)
            DUP;        # storage.storage.pair(params, storage)
            CDADR;      # Map(string, string).storage.pair(params, storage)
            DUUUP;      # pair(params, storage).Map(string, string).storage.pair(params, storage)
            CAAR;       # string.Map(string, string).storage.pair(params, storage)
            DUUUUP;     # pair(params, storage).string.Map(string, string).storage.pair(params, storage)
            CADR;       # string.string.Map(string, string).storage.pair(params, storage)
            SOME;       # option(string).string.Map(string, string).storage.pair(params, storage)
            SWAP;       # string.option(string).Map(string, string).storage.pair(params, storage)
            UPDATE;     # Map(string, string).storage.pair(params, storage)
            SWAP;       # storage.Map(string, string).pair(params, storage)
            SET_CDADR;  # storage.pair(params, storage)
            SWAP;       # pair(params, storage).storage
            DROP;       # storage
            NIL operation; # operations.storage
            PAIR;       # pair(operations, storage)
          }; # pair(operations, storage)
      }
      {
        # Entry point: setPause # params.storage
        PAIR;       # pair(params, storage)
        # sp.verify(sp.sender == self.data.admin) # pair(params, storage)
        DUP;        # pair(params, storage).pair(params, storage)
        CDDAAR;     # address.pair(params, storage)
        SENDER;     # address.address.pair(params, storage)
        COMPARE;    # int.pair(params, storage)
        EQ;         # bool.pair(params, storage)
        IF
          {}
          {
            PUSH string "WrongCondition: sp.sender == self.data.admin"; # string.pair(params, storage)
            FAILWITH;   # pair(params, storage)
          }; # pair(params, storage)
        # self.data.paused = params # pair(params, storage)
        DUP;        # pair(params, storage).pair(params, storage)
        CDR;        # storage.pair(params, storage)
        DUUP;       # pair(params, storage).storage.pair(params, storage)
        CAR;        # params.storage.pair(params, storage)
        SWAP;       # storage.params.pair(params, storage)
        SET_CDDR;   # storage.pair(params, storage)
        SWAP;       # pair(params, storage).storage
        DROP;       # storage
        NIL operation; # operations.storage
        PAIR;       # pair(operations, storage)
      }; # pair(operations, storage)
  } # pair(operations, storage);